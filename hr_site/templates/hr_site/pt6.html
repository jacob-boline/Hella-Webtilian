<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanilla JS Parallax Scroll</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css">
    <style>
        * {
            padding: 0;
            margin: 0;
        }


        div#parallax-wrapper {
            position: relative;
            align-items: center;
            text-align: center;
        }

        .parallax-section {
            position: relative;
            overflow: hidden;
            height: auto;
            padding: 0;
        }

        .parallax-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
        }

        .parallax-content {
            position: relative;
            z-index: 2;
            padding: 10vh 5vw;
            background: rgba(255, 255, 255, 0.8);
            max-width: 80%;
        }

        .section-wipe {
            position: absolute;
            left: 0;
            {#min-width: 100vw;#}
            {#max-width:100vw;#}
            {#width: 100vw;#}
            min-width: 100%;
            max-width: 100%;
            width: 100%;
            height: 60vh;
            background-size: cover;
            background-position: center;
            z-index: 20;
            transform: translateY(0);
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="parallax-wrapper">

        <section id="parallax-section-1" class="parallax-section">
            <div class="parallax-background" style="background-image: url('https://wallpapercat.com/w/full/3/6/b/56138-1284x2778-phone-hd-neon-wallpaper.jpg');"></div>
            <div class="parallax-content max-w-4xl mx-auto">
                <h1 class="text-4xl font-bold">Parallax Section 1</h1>
                {% lorem 25 p %}
                <h1 class="text-4xl font-bold">END SECTION</h1>
            </div>
        </section>

        <div id="section-wipe-1" class="section-wipe" style="background-image: url('https://wallpapers.com/images/hd/ultra-hd-dual-monitor-j57d6vs60uvvwnb2.jpg');"></div>

        <section id="parallax-section-2" class="parallax-section">
            <div class="parallax-background" style="background-image: url('https://images.unsplash.com/photo-1562575214-da9fcf59b907?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8dGVjaG5vbG9neSUyMGJhY2tncm91bmR8ZW58MHx8MHx8fDA%3D');"></div>
            <div class="parallax-content max-w-4xl mx-auto">
                <h1 class="text-4xl font-bold">Parallax Section 2</h1>
                {% lorem 25 p %}
                <h1 class="text-4xl font-bold">END SECTION</h1>
            </div>
        </section>

    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {

            let parallaxSpeed = 0.5;
            let wipes = document.querySelectorAll(".section-wipe");
            let wipeData = {};
            let activeWipe = null;
            let ticking = false;

            function initializeParallax() {
                document.querySelectorAll('.parallax-section').forEach(section => {
                    let content = section.querySelector('.parallax-content');
                    let background = section.querySelector('.parallax-background');
                    let viewportHeight = document.documentElement.clientHeight;
                    let adjustedHeight = Math.max(content.offsetHeight, viewportHeight);
                    section.style.height = `${adjustedHeight}px`;
                    background.style.height = `${adjustedHeight}px`;
                });
            }

            function updateParallax(scrollTop) {
                document.querySelectorAll('.parallax-section.in-view').forEach(section => {
                    let sectionOffset = section.offsetTop;
                    let background = section.querySelector('.parallax-background');
                    background.style.transform = `translateY(${(scrollTop - sectionOffset) * parallaxSpeed}px)`;
                });
            }

            function calculateWipeData() {
                wipes.forEach(wipe => {
                    let wipeHeight = wipe.getBoundingClientRect().height;
                    let viewportHeight = document.documentElement.clientHeight - 30;
                    let scrollSpeedRatio = (viewportHeight + wipeHeight) / viewportHeight;
                    let wipeOffset = wipe.getBoundingClientRect().top + window.scrollY;
                    wipeData[wipe.id] = { scrollSpeedRatio, wipeOffset };
                });
            }

            function positionSectionWipes() {
                document.querySelectorAll('.section-wipe').forEach(wipe => {
                    let nextSection = wipe.nextElementSibling;
                    if (nextSection && nextSection.classList.contains('parallax-section')) {
                        wipe.style.top = `${nextSection.getBoundingClientRect().top + window.scrollY}px`;
                    }
                });
            }

            function handleScroll() {
                if (!activeWipe || !wipeData[activeWipe.id]) return;

                let scrollPosition = window.scrollY;
                let { scrollSpeedRatio, wipeOffset } = wipeData[activeWipe.id];
                let viewportHeight = document.documentElement.clientHeight;
                let progress = (scrollPosition - wipeOffset + viewportHeight) / viewportHeight;
                if (progress >= 0) {
                    let fasterScroll = (scrollPosition - wipeOffset + viewportHeight) / scrollSpeedRatio;
                    activeWipe.style.transform = `translateY(-${fasterScroll}px)`;
                }
            }

            function observeWipes() {
                let observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            activeWipe = entry.target;
                            window.addEventListener("scroll", handleScroll);
                        } else if (activeWipe === entry.target) {
                            activeWipe = null;
                            window.removeEventListener("scroll", handleScroll);
                        }
                    });
                }, { threshold: 0 });

                wipes.forEach(wipe => observer.observe(wipe));
            }

            function observeElements() {
                let observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('in-view');
                        } else {
                            entry.target.classList.remove('in-view');
                        }
                    });
                }, { threshold: 0 });

                document.querySelectorAll('.parallax-section').forEach(section => observer.observe(section));
            }

            function onScroll() {
                if (!ticking) {
                    ticking = true;
                    requestAnimationFrame(() => {
                        updateParallax(window.scrollY);
                        ticking = false;
                    });
                }
            }

            function debounce(func, wait = 200) {
                let timeout;
                return function () {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, arguments), wait);
                };
            }

            initializeParallax();
            positionSectionWipes();
            calculateWipeData();
            observeWipes();
            observeElements();

            window.addEventListener('scroll', onScroll);
            window.addEventListener('resize', debounce(() => {
                positionSectionWipes();
                calculateWipeData();
            }));
        });
    </script>
</body>
</html>





















{#<!DOCTYPE html>#}
{#<html lang="en">#}
{#<head>#}
{#    <meta charset="UTF-8">#}
{#    <meta name="viewport" content="width=device-width, initial-scale=1.0">#}
{#    <title>Parallax Scroll Page</title>#}
{#    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>#}
{#    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css"></script>#}
{#    <style>#}
{##}
{#        * {#}
{#            padding: 0;#}
{#            margin: 0;#}
{#        }#}
{##}
{#        div#parallax-wrapper {#}
{#            position: relative;#}
{#            align-items: center;#}
{#            text-align: center;#}
{#        }#}
{##}
{#        .parallax-section {#}
{#            position: relative;#}
{#            overflow: hidden;#}
{#            height: auto;#}
{#            padding: 0;#}
            {#display: flex;#}
            {#justify-content: center;#}
{#        }#}
{##}
{#        .parallax-background {#}
{#            position: absolute;#}
{#            top: 0;#}
{#            left: 0;#}
{#            width: 100%;#}
{#            background-size: cover;#}
{#            background-attachment: fixed;#}
{#            background-position: center;#}
{#        }#}
{##}
{#        .parallax-content {#}
{#            position: relative;#}
{#            z-index: 2;#}
{#            padding: 10vh 5vw;#}
{#            background: rgba(255, 255, 255, 0.8);#}
{#            max-width: 80%;#}
{#        }#}
{##}
{#        .section-wipe {#}
{#            position: absolute;#}
            {#top: 0;#}
{#            left: 0;#}
{#            min-width: 100vw;#}
{#            height: 60vh;#}
{#            background-size: cover;#}
{#            background-position: center;#}
{#            z-index: 20;#}
{#            transform: translateY(0);#}
{#            pointer-events: none;#}
{#        }#}
{#    </style>#}
{#</head>#}
{#<body class="bg-gray-100">#}
{##}
{#    <div id="parallax-wrapper">#}
{##}
{#        <section id="parallax-section-1" class="parallax-section">#}
{#            <div class="parallax-background" style="background-image: url('https://wallpapercat.com/w/full/3/6/b/56138-1284x2778-phone-hd-neon-wallpaper.jpg');"></div>#}
{#            <div class="parallax-content max-w-4xl mx-auto">#}
{#                <h1 class="text-4xl font-bold">Parallax Section 1</h1>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                            <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                            <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <h3 class="text-center">END</h3>#}
{#            </div>#}
{#        </section>#}
{##}
{#        <div id="section-wipe-1" class="section-wipe" style="background-image: url('https://wallpapers.com/images/hd/ultra-hd-dual-monitor-j57d6vs60uvvwnb2.jpg');"></div>#}
{##}
{##}
{#        <section id="parallax-section-2" class="parallax-section">#}
{#            <div class="parallax-background" style="background-image: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSpvsq4bUiKH9N8_6ASAT40k2T1kHAcQqvYKw&s');"></div>#}
{#            <div class="parallax-content max-w-4xl mx-auto">#}
{#                <h1 class="text-4xl font-bold">Parallax Section 2</h1>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                            <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                            <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <p>so, i want to create a page that is comprised of: 1) A variable length#}
{#              body of text. 2) A background image that has a parallax scroll effect#}
{#              3) The text should have a top and bottom padding of 10vh. 4) For the#}
{#              sake of this formula, let's say that the text's scroll speed is 1.0,#}
{#              then the scroll speed of the background image would be something like#}
{#              '0.xx'. The scroll height ratio is the value of 1.0 / 0.xx 5) To#}
{#              determine the height of the background image, the formula would be the#}
{#              height of the element containing the text multiplied by the scroll#}
{#              height ratio (unless you think this is incorrect) 6) This will be#}
{#              called parallax-section-1. 7) Directly following this will be another#}
{#              section with the same design, called parallax-section-2 8) There will#}
{#              be a section wipe element that is comprised of a full width,#}
{#              banner-like image, called section-wipe-1 9) section-wipe-1 will need#}
{#              to have a higher z-index than either of the parallax-section's 10) Its#}
{#              starting position on the page should be with its top edge/border at#}
{#              the same position as the top edge/border of parallax-section-2 11)#}
{#              Once the section-wipe intersects the viewport a new scroll-speed will#}
{#              be applied to it. 12) This scroll speed will be reference as#}
{#              'section-wipe-scroll-speed'. 13) 'section-wipe-scroll-speed' will be#}
{#              defined as ((viewport height + section-wipe-1 height)/viewport height)#}
{#              14) This scroll speed is supposed to make it so that the bottom#}
{#              edge/border of section-wipe-1 should intersect the top of the viewport#}
{#              at the same time as the top edge/border of parallax-section-2 (correct#}
{#              me if i'm wrong) Please generate the jquery/js/html/css to create#}
{#              this. If it makes sense -- is more efficient or increases readability,#}
{#              etc. -- to use frameworks/libraries along the lines of#}
{#              tailwind/bootstrap/htmx/etc. then do so. 2/2 ChatGPT said: Here's a#}
{#              fully functional implementation of your parallax scrolling effect#}
{#              using Tailwind CSS and jQuery. It includes: Two parallax sections#}
{#              (parallax-section-1 and parallax-section-2). A section wipe#}
{#              (section-wipe-1) that overlays the second parallax section at the#}
{#              correct scroll timing. Calculations for dynamic parallax speeds and#}
{#              scroll height ratios. Smooth parallax effects using JavaScript and#}
{#              CSS. I'll generate the complete code for you now. Parallax Scroll Page#}
{#              Answer in chat instead This implementation includes: Parallax Sections#}
{#              (parallax-section-1 & parallax-section-2): Background image moves at a#}
{#              slower scroll speed (0.5 relative to 1.0 content scroll speed).#}
{#              Background height dynamically adjusts based on the scroll height#}
{#              ratio. Section Wipe (section-wipe-1): Appears at the right position.#}
{#              Moves at section-wipe-scroll-speed to synchronize with#}
{#              parallax-section-2. Smooth scrolling logic: Updates both parallax and#}
{#              section wipe movement on scroll. Dynamically calculates section#}
{#              heights and positioning. Let me know if you need adjustments! ðŸš€</p>#}
{#                <h3 class="text-center">END</h3>#}
{#            </div>#}
{#        </section>#}
{##}
{#    </div>#}
{##}
{#    <script>#}
{#        $(document).ready(function () {#}
            {#    let scrollSpeed = 1.0;#}
            {#    let parallaxSpeed = 0.5;#}
            {#    //let scrollHeightRatio = scrollSpeed / parallaxSpeed;#}
            {#    let scrollHeightRatio = parallaxSpeed / scrollSpeed;#}
            {#    let parallaxHeightRatio = scrollSpeed / parallaxSpeed;#}
            {#    let viewportHeight = window.innerHeight;#}
            {#    let wipes = document.querySelectorAll(".section-wipe");#}
            {#    let wipeData = {}; // Store scrollSpeedRatio & height for each wipe#}
            {#    let activeWipe = null; // Currently intersecting wipe#}
            {##}
            {##}
            {#    function initializeParallax() {#}
            {#        $('.parallax-section').each(function () {#}
            {##}
            {#            let content = $(this).find('.parallax-content');#}
            {#            let background = $(this).find('.parallax-background');#}
            {#            let section = $(this);#}
            {##}
            {#            //let paddingTop = parseFloat(content.css('padding-top'));#}
            {#            //let paddingBottom = parseFloat(content.css('padding-bottom'));#}
            {#            //let viewportHeight = $(window).height();#}
            {#let adjustedHeight = contentHeight * scrollHeightRatio;#}
            {#            let adjustedHeight = content.outerHeight();#}
            {#            adjustedHeight = Math.max(adjustedHeight, viewportHeight);#}
            {#            //let extraHeightFromCentering = contentHeight <= viewportHeight ? (viewportHeight - contentHeight) / 2 : 0;#}
            {#            //let adjustedHeight = (contentHeight - (paddingTop + paddingBottom)) * scrollHeightRatio + (paddingTop + paddingBottom); //* scrollHeightRatio + extraHeightFromCentering;#}
            {#            //adjustedHeight = Math.max(adjustedHeight, viewportHeight);#}
            {#            section.css({ height: adjustedHeight + 'px' });#}
            {#            background.css({ height: adjustedHeight + 'px' });#}
            {##}
            {#            //section.css({ height: adjustedHeight + 'px', alignItems: contentHeight <= viewportHeight ? 'center' : 'flex-start' });#}
            {#        });#}
            {#    }#}
            {#    #}
            {#    function updateParallax(scrollTop) {#}
            {#        $('.parallax-section').each(function () {#}
            {#            if ($(this).hasClass('in-view')) {#}
            {#                let sectionOffset = $(this).offset().top;#}
            {#                let background = $(this).find('.parallax-background');#}
            {#                background.css({#}
            {#                    transform: `translateY(${(scrollTop - sectionOffset) * parallaxSpeed}px)`#}
            {#                });#}
            {#            }#}
            {#        });#}
            {#    }#}
            {##}
            {##}
            {##}
            {#function calculateWipeData() {#}
            {#    //let viewportHeight = window.innerHeight;#}
            {##}
            {#    wipes.forEach((wipe) => {#}
            {#        let wipeHeight = wipe.offsetHeight;#}
            {#        let associatedSection = wipe.closest('.parallax-section'); // Get the section before it#}
            {#        let sectionOffset = associatedSection.offsetTop;#}
            {##}
            {#        wipeData[wipe.id] = {#}
            {#            scrollSpeedRatio: (viewportHeight + wipeHeight) / viewportHeight,#}
            {#            sectionOffset: sectionOffset,#}
            {#        };#}
            {#    });#}
            {##}
            {##}
            {##}
            {#    function calculateWipeData() {#}
            {#        wipes.forEach((wipe) => {#}
            {#            let wipeHeight = wipe.offsetHeight;#}
            {#            let wipeOffset = wipe.getBoundingClientRect().top + window.scrollY; // Absolute position#}
            {#            //let viewportHeight = window.innerHeight;#}
            {##}
            {#            wipeData[wipe.id] = {#}
            {#                scrollSpeedRatio: (viewportHeight + wipeHeight) / viewportHeight,#}
            {#                wipeOffset: wipeOffset,#}
            {#            };#}
            {##}
            {#            console.log(`[calculateWipeData] Wipe ID: ${wipe.id}, Offset: ${wipeOffset}, Scroll Speed Ratio: ${wipeData[wipe.id].scrollSpeedRatio}`);#}
            {#        });#}
            {#    }#}
            {##}
            {#    function positionSectionWipes() {#}
            {#        $('.section-wipe').each(function () {#}
            {#            let wipe = $(this);#}
            {#            let nextSection = wipe.next('.parallax-section');#}
            {##}
            {#            if (nextSection.length) {#}
            {#                let nextSectionOffset = nextSection.offset().top;#}
            {#                wipe.css('top', nextSectionOffset + 'px');#}
            {#            }#}
            {#        });#}
            {#    }#}
            {##}
            {#function handleScroll() {#}
            {#    if (!activeWipe) return;#}
            {##}
            {#    let scrollPosition = window.scrollY;#}
            {##}
            {#    let { scrollSpeedRatio, sectionOffset } = wipeData[activeWipe.id];#}
            {##}
            {#    if (scrollPosition >= sectionOffset) {#}
            {#        let progress = (scrollPosition - sectionOffset) / viewportHeight;#}
            {#        let fasterScroll = progress * viewportHeight * scrollSpeedRatio;#}
            {#        activeWipe.style.transform = `translateY(-${fasterScroll}px)`;#}
            {#    }#}
            {##}
            {##}
            {##}
            {#    function handleScroll() {#}
            {#        if (!activeWipe) return;#}
            {##}
            {#        let scrollPosition = window.scrollY;#}
            {#        let { scrollSpeedRatio, wipeOffset } = wipeData[activeWipe.id];#}
            {##}
            {#        // Calculate when the wipe first enters the viewport#}
            {#        let progress = ((scrollPosition - wipeOffset + viewportHeight) / viewportHeight);#}
            {##}
            {#        if (progress >= 0) { // Ensure the wipe effect only applies when it's visible#}
            {#let fasterScroll = progress * (viewportHeight * scrollSpeedRatio / 4);#}
            {#            let fasterScroll = (scrollPosition - wipeOffset + viewportHeight) / scrollSpeedRatio;#}
            {#let fasterScroll = ((progress * .5) * (viewportHeight * scrollSpeedRatio)) / 4;#}
            {#            activeWipe.style.transform = `translateY(-${fasterScroll}px)`;#}
            {##}
            {#            console.log(`[handleScroll] Scroll Position: ${scrollPosition}, Wipe Offset: ${wipeOffset}, Progress: ${progress}, Transform: ${fasterScroll}px`);#}
            {#        }#}
            {#    }#}
            {##}
            {##}
            {##}
            {##}
            {#    function observeWipes() {#}
            {#        let observerOptions = { root: null, threshold: 0 };#}
            {#        let observer = new IntersectionObserver((entries) => {#}
            {#            entries.forEach((entry) => {#}
            {#                let logCount = 0;#}
            {#                if (entry.isIntersecting) {#}
            {#                    if (logCount === 0) {#}
            {#                        console.log('wipe is intersecting');#}
            {#                        logCount++;#}
            {#                    }#}
            {#                    activeWipe = entry.target;#}
            {#                    window.addEventListener("scroll", handleScroll);#}
            {#                } else if (activeWipe === entry.target) {#}
            {#                    if (logCount !== 0) {#}
            {#                        console.log('wipe is not intersecting');#}
            {#                    }#}
            {#                    activeWipe = null;#}
            {#                    window.removeEventListener("scroll", handleScroll);#}
            {#                }#}
            {#            });#}
            {#        }, observerOptions);#}
            {##}
            {#        wipes.forEach((wipe) => observer.observe(wipe));#}
            {#    }#}
            {##}
            {#    function observeElements() {#}
            {#        let observer = new IntersectionObserver(entries => {#}
            {#            entries.forEach(entry => {#}
            {#                let logCount = 0;#}
            {#                if (entry.isIntersecting) {#}
            {#                    if (logCount === 0) {#}
            {#                        console.log('is intersecting');#}
            {#                        logCount++;#}
            {#                    }#}
            {#                    $(entry.target).addClass('in-view');#}
            {#                } else {#}
            {#                    if (logCount !== 0) {#}
            {#                        console.log('is not intersecting');#}
            {#                    }#}
            {#                    $(entry.target).removeClass('in-view');#}
            {#                }#}
            {#            });#}
            {#        }, {threshold: 0});#}
            {##}
            {#        $('.parallax-section').each(function () {#}
            {#            observer.observe(this);#}
            {#        });#}
            {#    }#}
            {##}
            {#    #}
            {#    initializeParallax();#}
            {#    positionSectionWipes();#}
            {#    calculateWipeData();#}
            {#    observeWipes();#}
            {#    observeElements();#}
            {#    #}
            {#    $(window).on('scroll', function () {#}
            {#        let scrollTop = $(window).scrollTop();#}
            {#        updateParallax(scrollTop);#}
            {#    });#}
            {##}
            {#    $(window).on('resize', function () {#}
            {#        positionSectionWipes();#}
            {#        calculateWipeData();#}
            {#    });#}
            {#);#}
{#            let scrollSpeed = 1.0;#}
{#            let parallaxSpeed = 0.5;#}
            {#let scrollHeightRatio = parallaxSpeed / scrollSpeed;#}
{#            //let viewportHeight = window.innerHeight;#}
{#            //let viewportHeight = document.documentElement.clientHeight;#}
{#            let wipes = document.querySelectorAll(".section-wipe");#}
{#            let wipeData = {}; // Store scrollSpeedRatio & height for each wipe#}
{#            let activeWipe = null; // Currently intersecting wipe#}
{#            let ticking = false; // For requestAnimationFrame optimization#}
{##}
{#            function initializeParallax() {#}
{#                document.querySelectorAll('.parallax-section').forEach(section => {#}
{#                    let content = section.querySelector('.parallax-content');#}
{#                    let background = section.querySelector('.parallax-background');#}
{#                    let viewportHeight = document.documentElement.clientHeight;#}
{#                    let adjustedHeight = Math.max(content.offsetHeight, viewportHeight);#}
{#                    section.style.height = `${adjustedHeight}px`;#}
{#                    background.style.height = `${adjustedHeight}px`;#}
{#                });#}
{#            }#}
{##}
{#            function updateParallax(scrollTop) {#}
{#                document.querySelectorAll('.parallax-section.in-view').forEach(section => {#}
{#                    let sectionOffset = section.offsetTop;#}
{#                    let background = section.querySelector('.parallax-background');#}
{#                    background.style.transform = `translateY(${(scrollTop - sectionOffset) * parallaxSpeed}px)`;#}
{#                });#}
{#            }#}
{##}
{#            function calculateWipeData() {#}
{#                wipes.forEach(wipe => {#}
{#                    let wipeHeight = wipe.getBoundingClientRect().height;#}
                    {#let wipeHeight = wipe.offsetHeight;#}
{#                    //let viewportHeight = document.documentElement.clientHeight;#}
{#                    let viewportHeight = document.documentElement.clientHeight;#}
{#                    let scrollSpeedRatio = (viewportHeight + wipeHeight) / viewportHeight;#}
{#                    //let wipeOffset = wipeHeight + window.scrollY;#}
{#                    let rect = wipe.getBoundingClientRect();#}
{#                    let style = window.getComputedStyle(wipe);#}
{#                    let marginTop = parseFloat(style.marginTop) || 0;#}
{#                    console.log(`marginTop: ${marginTop}`);#}
{#                    let wipeOffset = rect.top + window.scrollY - marginTop;#}
{#                    //let wipeOffset = wipe.getBoundingClientRect().top + window.scrollY;#}
{#                    wipeData[wipe.id] = {#}
{#                        scrollSpeedRatio: scrollSpeedRatio,#}
{#                        wipeOffset: wipeOffset#}
{#                    };#}
{#                    console.log(`Wipe Height: ${wipeHeight}`);#}
{#                    console.log(`viewPortHeight: ${viewportHeight}`);#}
                    {#let wipeOffset = wipe.getBoundingClientRect().top + window.scrollY;#}
                    {#wipeData[wipe.id] = {#}
                    {#    scrollSpeedRatio: (viewportHeight + wipe.offsetHeight) / viewportHeight,#}
                    {#    wipeOffset: wipeOffset,#}
                    {#;#}
{#                });#}
{##}
{#                console.log("Wipe Data:", wipeData);#}
{#            }#}
{##}
{#            function positionSectionWipes() {#}
{#                document.querySelectorAll('.section-wipe').forEach(wipe => {#}
{#                    let nextSection = wipe.nextElementSibling;#}
{#                    if (nextSection && nextSection.classList.contains('parallax-section')) {#}
{#                        //wipe.style.top = `${nextSection.offsetTop}px`;#}
{#                        wipe.style.top = `${nextSection.getBoundingClientRect().top + window.scrollY}px`;#}
{#                    }#}
{#                });#}
{#            }#}
{##}
{#            function handleScroll() {#}
{#                if (!activeWipe || !wipeData[activeWipe.id]) return;#}
{##}
{#                let scrollPosition = window.scrollY;#}
{#                let {scrollSpeedRatio, wipeOffset} = wipeData[activeWipe.id];#}
{#                let viewportHeight = document.documentElement.clientHeight;#}
{#                let progress = (scrollPosition - wipeOffset + viewportHeight) / viewportHeight;#}
{#                if (progress >= 0) {#}
{#                    let fasterScroll = (scrollPosition - wipeOffset + viewportHeight) / scrollSpeedRatio;#}
{#                    activeWipe.style.transform = `translateY(-${fasterScroll}px)`;#}
{#                }#}
{#            }#}
{##}
{#            function observeWipes() {#}
{#                let observerOptions = {root: null, threshold: 0};#}
{#                let observer = new IntersectionObserver(entries => {#}
{#                    entries.forEach(entry => {#}
{#                        if (entry.isIntersecting) {#}
{#                            activeWipe = entry.target;#}
{#                            window.addEventListener("scroll", handleScroll);#}
{#                        } else if (activeWipe === entry.target) {#}
{#                            activeWipe = null;#}
{#                            window.removeEventListener("scroll", handleScroll);#}
{#                        }#}
{#                    });#}
{#                }, observerOptions);#}
{##}
{#                wipes.forEach(wipe => observer.observe(wipe));#}
{#            }#}
{##}
{#            function observeElements() {#}
{#                let observer = new IntersectionObserver(entries => {#}
{#                    entries.forEach(entry => {#}
{#                        if (entry.isIntersecting) {#}
{#                            entry.target.classList.add('in-view');#}
{#                        } else {#}
{#                            entry.target.classList.remove('in-view');#}
{#                        }#}
{#                    });#}
{#                }, {threshold: 0});#}
{##}
{#                document.querySelectorAll('.parallax-section').forEach(section => observer.observe(section));#}
{#            }#}
{##}
{#            function onScroll() {#}
{#                if (!ticking) {#}
{#                    ticking = true;#}
{#                    requestAnimationFrame(() => {#}
{#                        updateParallax(window.scrollY);#}
{#                        ticking = false;#}
{#                    });#}
{#                }#}
{#            }#}
{##}
{#            function debounce(func, wait = 200) {#}
{#                let timeout;#}
{#                return function () {#}
{#                    clearTimeout(timeout);#}
{#                    timeout = setTimeout(() => func.apply(this, arguments), wait);#}
{#                };#}
{#            }#}
{##}
{#            initializeParallax();#}
{#            positionSectionWipes();#}
{#            calculateWipeData();#}
{#            observeWipes();#}
{#            observeElements();#}
{##}
{##}
{#            window.addEventListener('scroll', onScroll);#}
{#            window.addEventListener('resize', debounce(() => {#}
{#                positionSectionWipes();#}
{#                calculateWipeData();#}
{#            }));#}
{##}
{#            document.querySelectorAll('.parallax-section').forEach(section => {#}
{#                console.log(`Height of ${section.id || "Unnamed Section"}:`, section.offsetHeight);#}
{#            });#}
{#        });#}
{#    </script>#}
{#</body>#}
{#</html>#}
{##}
